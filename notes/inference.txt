
- type inference can introduce only unif variables
- unif variables have no relevance annotation
- My Haskell patterns (H xs) are simpler than they really should be.
  But it's annoying otherwise. I'm not writing a pattern-matching compiler.
- Fix requires its argument to take a visible argument. I just can't
  be bothered to generalize this.
- Not sure whether to use subsumption or straight-up equality in
  matchExpectedFunTy (|->fun). GHC uses subsumption here. But I think
  an equality predicate is powerful enough.
- No constraints! This is because everything has a name.
- Class constraints are precisely inferred relevant arguments.
- We can't always just use a coercion in |->fun because then we won't be
  able to recognize proper dependent function types. In other words,
  application forms default to non-dependent application.
- Instances are just another form of given, and happily live in G/P
- ITyC_Case is in the unstarred judgment, because of tauifyMultipleMatches
- Similarly, |->alt can use the unstarred checking judgment, for the same reason.
- Worker/wrapper is compulsory. There is no syntax for H in Haskell, only
  x. Why? Because otherwise, we can't use visible type application on universals,
  which is quite annoying in practice.
  Example: just : UPI (a :Irrel Type{}). MPI (x :Rel a). Maybe{} a
           just = \ @(a :Irrel Type{}). Just{a}
  It's important to keep the MPIs where possible for unsaturated matching.
- There are two sets of variable names. a,b,x denote names a Haskell user can
  write. $a denotes a name that a Haskell user cannot write. All are valid
  names in Pico, and we can freely rename between. Note use in ITyC_SkolRel.
- Case has an synthesis version that doesn't use the dependent equality and
  and checking version that does.
- Very cool how the inference rules match the code. Even the difference between
  matchExpectedFunTy and matchActualFunTy is present.
- Unclear where ITyC_Fix should live. Starred judgment or not? I think this
  difference is noticeable by the user. AHA! Decision: never duplicate a polytype.
  Therefore: Fix must live in the unstarred judgment.
- Generalizing unification variables is simpler in the implementation: we
  just wrap in an implication constraint. Why no need for substitution?
- We don't need "touchable" variables to be tracked. We just stop unifying
  once we walk past an equality constraint in the unification telescope
- IGen_Ty is a bit punny around dom(d)
- SB_DeepSkol from VTA paper has become ITyC_Skol. Note that it's not deep.
  We thus must generalize in the Infer rule. At first, I was quite concerned
  about solving in the middle of constraint generation. But GHC actually
  does this, too, whenever it encounters a let.
- Label given class constraints with :c
- The old +> judgment (see paper from 2 years ago) required funny business
  around quantifying over propositions... and it also required having the
  body of a Pi-type be something other than *. All for syntactic silliness.
  So I've introduced :g bindings.
- Put givens in O with :g
- Don't differentiate Constraint from Type. See PtC_Constrained.
- Can't really do decideGeneralisationPlan (i.e. Let should not be generalized)
  properly because I can't easily distinguish between top-level and local
  lets. Solution: consider a top-level let a new declaration form, just like
  OutsideIn. Do generalization there.
- Use g(D) to make all bindings givens.
- Must comment about how |- judgments are extended. In particular, |-ctx.
  With UCtx_TyVar and UCtx_CoVar
- And we only allow Inf on coercion abstractions.
- Givens are *not* available to the right of |-.
- All unification variables must be gone during zonking.
- Only unification variable kinds can refer to givens.
- :c is just like :g, except the solver uses :c bindings.
- prop:solver-sound implies that no unif variables that depend on a given
  can be generalized over. This is correct.

Design decisions:
- Include let (with a desugaring to use lambda) but not letrec. The only
  way I can see doing letrec is to mimic GHC's local monomorphic functions
  and exported polymorphic functions (i.e. AbsBinds), and I don't want to
  get involved with that. I will comment about this in the writeup.

Preprocessing:
- Each qvar is appropriately labeled.
- `case scrut of _ -> blah` becomes `blah`
- case patterns are expanded out (a la Match.hs)
- redundant matches are dropped
   --> Thus, the first alt, if there is one, has a constructor


Lemma: (DONE, I THINK)
If S;P |-> ... -| O; C, then S |-ictx P,O

Lemma: (OLD)
If O1 +> D ~> O2 and S |-ictx P,D,O1
then S |-ictx P,O2

Lemma: (WORKING ON IT)
If S;P |->ty _t ~> t : k -| O; C,
then S;P,O |- t : k

Lemma: (DONE)
If S;P |-ty k : Type{} and S;P |->ty _t : k ~> ..., then ...
(We need k to be well-formed!)

Lemma: (OLD)
If S;P,d,O |-ty t : k and O +> d ~> O'; theta, then
S;P,O',d |-ty t[theta] : k[theta]
