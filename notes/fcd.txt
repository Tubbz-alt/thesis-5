TO PROVE:
 - Preservation
 - Progress (which now requires lifting)
 - Type erasure vis-a-vis relevance
 - 'twould be fun to relate relevance and roles.

Binders store the following flags:
 - relevance
 - matchability

 - BUT NOT visibility
 - OR dependency


Features missing:
 - levity polymorphism (would need to generalize Ty_Pi)
 - Left/Right. Sorta impossible.

Notation:
%% - a -> b means (_ :(Nondep,Rel,Vis,Mat) a. b)
%% - a ~> b means (_ :(Nondep,Rel,Vis,Unm) a. b)
 - dom(D) is a list of type/coercion variables zs.
 - prefix(.) takes the prefix of a list
%% - Notation as:D means the lengths must match exactly
 - \tilde{\Pi} is the unmatchable Pi.
 - We write H for H[]
 
 - Rel(G) makes all bindings in G relevant.
%% - Irrel(G) is a no-op.
%% - Thus, rel(G) (with a metavariable rel) is well-defined.
%% - \neg rel is the opposite of rel.
%%    --> This Rel(G) operation is precisely Mishra-Linger's "context reset" operation

 - `let` in coercions is defined by macro-expansion

%% TysWiredIn:
%% S0 = (~) : (x1 :Irrel Type, x2 :Irrel Type, a1 :Rel x1, a2 :Rel x2)

Generativity/injectivity:
 - A generative/injective thing is called "matchable".
 - The opposite of "matchable" is "unmatchable".


Erasure:
 - We have coercion abstraction, which cannot get erased. But we will prove
   that type inference never creates a coercion abstraction except in the
   body of a pattern match. And in this position, whenever the match fires,
   it will get applied, as per S_Match. So we'll never get stuck on a
   coercion abstraction. Yet, coercion abstractions are useful in simplifying
   the grammar for case expressions (BIG WIN) and also in let-floating.
   Admittedly, a let-floated coercion abstraction might cause stuckness,
   but it is up to the optimizer to make sure this doesn't happen.

Unnecessary coercions:
  App
  PiCo
  Case
  Lam
  Fix
  ArgKLam
  InstLam
  Kind

  Con

  (Actually, just look it up in the git history.)

DESIGN DECISIONS:
 - Two instantiation operators: to make inversion work. Well, really, to
   make promotion work, but we've scrapped promotion. (I have undone this
   change in the rendering.)
 - Not putting coercion in the language of types: to avoid awkwardness of
   "lifting" a coercion in the lifting lemma. Spreads out complexity.
 - Not putting prop in type: Cleaner once the previous decision was made.
 - Different argument forms: To avoid overlap in the erased language.
   Note that ~> is untyped, so we can't tell the difference between
   relevant application and irrelevant application anymore.
 - Kinds in phi: to make CArgK{1,2} work. Note that we need these for
   CPush.
 - Not erasing the {} parameters to tycons: we need the kinds of the types
   in Nth to be joinable.
 - Looseness in R_Pi and R_Lam: necessary for completeness of rewrite
   relation. Otherwise, the induction hypothesis would be needed with
   a coercion variable in the context.
 - NB: Consistency depends on preservation for the Step case.
 - In my ott code, I always write the kinds as a self-check.
 - res must handle many cases at once, because we use it to look past
   the PIs in a partially-applied constant, and later telescope kinds
   might refer to earlier ones, even if the end result mentions only
   universals. Urgh.
 - The system is built so that preservation does not depend on consistency.
   If it did, we could erase the typing rule premises to the push rules
   other than for KPush, which is needed to extract the ts'.
 - The typing premise on Co_Step for the result is because preservation
   needs regularity (for S_APush). Without Co_Step's premise, regularity
   would need preservation. Alternatively, a premise could be added to APush.
   However, because consistency depends on regularity, making this change
   requires consistency to depend on preservation. This isn't harmful,
   but it all seems cleaner without this dependency.

build_kpush_co:

build_kpush_co(g; empty) = g
build_kpush_co(g; ts,t)  = let h = build_kpush_co(g; ts) in
                           h@(t ||> argk build_kpush_co(g; ts))

data T k where
  MkT :: forall a. Proxy (a :: k) -> MkT k

case (MkT Bool True (P Bool True)) |> co of ...
  where
    co :: T Bool ~ T s

-->

case (MkT s (True |> g0) (P Bool True |> g1)) of ...
  where
    g0 :: Bool ~ s
    g1 :: Proxy Bool True ~ Proxy s (True |> g0)

    g0 = argk (<forall k (a :: k). Proxy k a -> MkT k>@(nth 0 co))
    g1 = argk (<forall k (a :: k). Proxy k a -> MkT k>@(nth 0 co)@(<True> |>> g0)


Example:

  Replicate.

  Σ = Σ₀, Nat : (·)
        , Zero : (·; Nat)
	, Succ : (_ :R Nat; Nat)
	, Vec : (a : Type, n : Nat)
	, Nil : (c : n ~ Zero; Vec)
	, Cons : (n' :I Nat, c : n ~ Succ n', _ :R a, _:R Vec a n'; Vec)

  rep : Π~(a :I Type) (n :R Nat). a → Vec a n
  rep = λ(a :I Type).
        fix λ(r :R Π~(n :R Nat). a → Vec a n).
	    λ(n :R Nat).
	    λ(x :R a).
	    case_(Vec a n) n of
	      Zero → c. Nil a n c
	      Succ n' → c. Cons a n n' c x (r n' x)


------
Simplifications:
- Tried to remove g from grammar of types. Caused major headaches, because
  g1 ~ g2 is no longer well-formed. This way lies the X coercions of the
  "overabundance" paper. Ick.
  UPDATE: Actually, got this to work.

- Tried labeling applications. This seems like it could work better than
  the last fix, but I'm still unconvinced. It would mean making braced
  applications its own grammar to support lists, etc. Also, we should
  have braces in patterns, too.

- The three-binder approach to the Π-coercion runs into trouble in proving
  consistency, because it introduces a coercion variable. So I'm going with
  the asymmetrical one-binder approach, as implemented.


TODO: "other alternatives do not match" needs to be in the typing rule,
      not the step rule.

Stack:
  new res rules
