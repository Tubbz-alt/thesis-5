PROBLEMS:
 - ambiguity in grammar between τ ▹ η and γ ▹ η. These mean different things!
   Maybe change the latter to use ◃.

TO PROVE:
 - Preservation
 - Progress (which now requires lifting)
 - Type erasure vis-a-vis relevance
 - 'twould be fun to relate relevance and roles.

Binders store the following flags:
 - relevance
 - matchability

 - BUT NOT visibility
 - OR dependency


Features missing:
 - levity polymorphism (would need to generalize Ty_Pi)

Notation:
 - a -> b means (_ :(Nondep,Rel,Vis,Mat) a. b)
 - a ~> b means (_ :(Nondep,Rel,Vis,Unm) a. b)
 - We can use binders \delta in place of types and telescopes \Delta in place
   of lists of types.
 - dom(D) can be used as a list of types. See Tc_DataCon.
 - Notation as:prefix(D) means to zip the as with the D, doing telescopy
   substitution, and dropping any unmatched suffix
 - Notation as:D means the lengths must match exactly
 - \tilde{\Pi} is the unmatchable Pi.
 
 - Rel(G) makes all bindings in G relevant.
 - Irrel(G) is a no-op.
 - Thus, rel(G) (with a metavariable rel) is well-defined.
 - \neg rel is the opposite of rel.
    --> This Rel(G) operation is precisely Mishra-Linger's "context reset" operation

 - We can pretend phi is a type.

 - g1 ||> g2  :=    sym ((sym g1) <|| g2)
 - `let` in coercions is defined by macro-expansion

TysWiredIn:
S0 = (~) : (x1 :Irrel Type, x2 :Irrel Type, a1 :Rel x1, a2 :Rel x2)

Generativity/injectivity:
 - A generative/injective thing is called "matchable".
 - The opposite of "matchable" is "unmatchable".


Relevance:
 - The negation in the App rule is just contravariance. Clearly.


build_kpush_co:

build_kpush_co(g; empty) = g
build_kpush_co(g; ts,t)  = let h = build_kpush_co(g; ts) in
                           h@(t ||> argk build_kpush_co(g; ts))

data T k where
  MkT :: forall a. Proxy (a :: k) -> MkT k

case (MkT Bool True (P Bool True)) |> co of ...
  where
    co :: T Bool ~ T s

-->

case (MkT s (True |> g0) (P Bool True |> g1)) of ...
  where
    g0 :: Bool ~ s
    g1 :: Proxy Bool True ~ Proxy s (True |> g0)

    g0 = argk (<forall k (a :: k). Proxy k a -> MkT k>@(nth 0 co))
    g1 = argk (<forall k (a :: k). Proxy k a -> MkT k>@(nth 0 co)@(<True> |>> g0)


Example:

  Replicate.

  Σ = Σ₀, Nat : (·)
        , Zero : (·; Nat)
	, Succ : (_ :R Nat; Nat)
	, Vec : (a : Type, n : Nat)
	, Nil : (c : n ~ Zero; Vec)
	, Cons : (n' :I Nat, c : n ~ Succ n', _ :R a, _:R Vec a n'; Vec)

  rep : Π~(a :I Type) (n :R Nat). a → Vec a n
  rep = λ(a :I Type).
        fix λ(r :R Π~(n :R Nat). a → Vec a n).
	    λ(n :R Nat).
	    λ(x :R a).
	    case_(Vec a n) n of
	      Zero → c. Nil a n c
	      Succ n' → c. Cons a n n' c x (r n' x)
