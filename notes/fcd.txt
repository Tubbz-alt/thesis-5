TO PROVE:
 - Preservation
 - Progress (which now requires lifting)
 - Type erasure vis-a-vis relevance
 - 'twould be fun to relate relevance and roles.

Binders store the following flags:
 - relevance
 - matchability

 - BUT NOT visibility
 - OR dependency


Features missing:
 - levity polymorphism (would need to generalize Ty_Pi)
 - Left/Right. Sorta impossible.

Notation:
%% - a -> b means (_ :(Nondep,Rel,Vis,Mat) a. b)
%% - a ~> b means (_ :(Nondep,Rel,Vis,Unm) a. b)
 - dom(D) is a list of type/coercion variables zs.
 - prefix(.) takes the prefix of a list
%% - Notation as:D means the lengths must match exactly
 - \tilde{\Pi} is the unmatchable Pi.
 - We write H for H[]
 
 - Rel(G) makes all bindings in G relevant.
%% - Irrel(G) is a no-op.
%% - Thus, rel(G) (with a metavariable rel) is well-defined.
%% - \neg rel is the opposite of rel.
%%    --> This Rel(G) operation is precisely Mishra-Linger's "context reset" operation

 - `let` in coercions is defined by macro-expansion

%% TysWiredIn:
%% S0 = (~) : (x1 :Irrel Type, x2 :Irrel Type, a1 :Rel x1, a2 :Rel x2)

Generativity/injectivity:
 - A generative/injective thing is called "matchable".
 - The opposite of "matchable" is "unmatchable".


Erasure:
 - We have coercion abstraction, which cannot get erased. But we will prove
   that type inference never creates a coercion abstraction except in the
   body of a pattern match. And in this position, whenever the match fires,
   it will get applied, as per S_Match. So we'll never get stuck on a
   coercion abstraction. Yet, coercion abstractions are useful in simplifying
   the grammar for case expressions (BIG WIN) and also in let-floating.
   Admittedly, a let-floated coercion abstraction might cause stuckness,
   but it is up to the optimizer to make sure this doesn't happen.

Unnecessary coercions:
  App
  PiCo
  Case
  Lam
  Fix
  ArgKLam
  InstLam
  Kind

  Con

  (Actually, just look it up in the git history.)

DESIGN DECISIONS:
 - Two instantiation operators: to make inversion work. Well, really, to
   make promotion work, but we've scrapped promotion. (I have undone this
   change in the rendering.)
 - Not putting coercion in the language of types: to avoid awkwardness of
   "lifting" a coercion in the lifting lemma. Spreads out complexity.
 - Not putting prop in type: Cleaner once the previous decision was made.
 - Different argument forms: To avoid overlap in the erased language.
   Note that ~> is untyped, so we can't tell the difference between
   relevant application and irrelevant application anymore.
 - Kinds in phi: to make CArgK{1,2} work. Note that we need these for
   CPush.
 - Not erasing the {} parameters to tycons: we need the kinds of the types
   in Nth to be joinable.
 - Looseness in R_Pi and R_Lam: necessary for completeness of rewrite
   relation. Otherwise, the induction hypothesis would be needed with
   a coercion variable in the context.
 - NB: Consistency depends on preservation for the Step case.
 - In my ott code, I always write the kinds as a self-check.
 - res must handle many cases at once, because we use it to look past
   the PIs in a partially-applied constant, and later telescope kinds
   might refer to earlier ones, even if the end result mentions only
   universals. Urgh.
 - The system is built so that preservation does not depend on consistency.
   If it did, we could erase the typing rule premises to the push rules
   other than for KPush, which is needed to extract the ts'.
 - The typing premise on Co_Step for the result is because preservation
   needs regularity (for S_APush). Without Co_Step's premise, regularity
   would need preservation. Alternatively, a premise could be added to APush.
   However, because consistency depends on regularity, making this change
   requires consistency to depend on preservation. This isn't harmful,
   but it all seems cleaner without this dependency.
 - The three-binder approach to the Π-coercion runs into trouble in proving
   consistency, because it introduces a coercion variable. So I'm going with
   the asymmetrical one-binder approach, as implemented.
 - Need M/UPI to allow matching on partially applied things.
 - If we didn't have the c ~# g restrictions, we wouldn't be able
   to match on partially-applied GADT data constructors. See example below.
 - The ArgK rules, the Res rules, and the Inst rules all require the same PI
   to be used in both types in the proposition of a coercion. The coincidence
   of the PIs is not strictly necessary -- all the language properties we prove
   would remain true if we loosen this. However, the generality is never
   required, as a coercion between two different PIs is impossible without
   a bogus assumption. It seems simpler just to use the same PI on both sides,
   so that is what we do. Generalizing would allow us to also generalize the
   PushRel, PushIrrel, and CPush rules to allow different PIs on either side,
   but why bother?
 - Getting partially-applied matching to work is laborious. It requires complication
   in Ty_Case and Alt_Match, the MPI/UPI distinction, and unification in the typing
   rules (see critical use of matching in Alt_Match as used in the KPush case in
   the Progress theorem). See "weird case" below for an illustrative example of
   how hard this is.
 - "split" is a viable extension. But it's technically painful (requires a very
   baroque push rule and more kinds to be kept in the coercion-erased language).

Example about partially-applied GADT data constructors:

data T' = K'
data T = (T ~ T') => K

K :: PI c : T ~ T'. T

? :: T ~ T'
PI c:(<T>,<T'>).c  :: (PI c:T~T'. T) ~ (PI c:T~T'. T')

case K |> (PI c:T~T'. c) of
  K' -> ...


---------------
some scratchwork:

build_kpush_co:

build_kpush_co(g; empty) = g
build_kpush_co(g; ts,t)  = let h = build_kpush_co(g; ts) in
                           h@(t ||> argk build_kpush_co(g; ts))

data T k where
  MkT :: forall a. Proxy (a :: k) -> MkT k

case (MkT Bool True (P Bool True)) |> co of ...
  where
    co :: T Bool ~ T s

-->

case (MkT s (True |> g0) (P Bool True |> g1)) of ...
  where
    g0 :: Bool ~ s
    g1 :: Proxy Bool True ~ Proxy s (True |> g0)

    g0 = argk (<forall k (a :: k). Proxy k a -> MkT k>@(nth 0 co))
    g1 = argk (<forall k (a :: k). Proxy k a -> MkT k>@(nth 0 co)@(<True> |>> g0)

-------------------------
Example:

  Replicate.

  Σ = Σ₀, Nat : (·)
        , Zero : (·; Nat)
	, Succ : (_ :R Nat; Nat)
	, Vec : (a : Type, n : Nat)
	, Nil : (c : n ~ Zero; Vec)
	, Cons : (n' :I Nat, c : n ~ Succ n', _ :R a, _:R Vec a n'; Vec)

  rep : Π~(a :I Type) (n :R Nat). a → Vec a n
  rep = λ(a :I Type).
        fix λ(r :R Π~(n :R Nat). a → Vec a n).
	    λ(n :R Nat).
	    λ(x :R a).
	    case_(Vec a n) n of
	      Zero → c. Nil a n c
	      Succ n' → c. Cons a n n' c x (r n' x)


------------
Example of weird unsaturated case

data X where
  MkX :: MPI (k :Irrel Type) (a :Irrel k) (x :Rel Proxy k a). X

case_() (blah : MPI (a :Irrel Bool) (x :Rel Proxy Bool a). X) of
  MkX -> \ (k :Irrel Type) (c : blah [MPI (a:Irrel Bool) (x :Rel Proxy Bool x). X]~[MPI (a :Irrel k) (x :Rel Proxy k a). X] MkX k) -> ()

case_() (blah : MPI (a :Irrel Type) (x :Rel Type). X) of
  MkX -> \ (k :Irrel Type) (c : blah [MPI (a:Irrel Type) (x :Rel Type). X]~[MPI (a :Irrel k) (x :Rel Proxy k a). X] MkX k) -> ()



TODO: ~# still doesn't allow c in η.
