%% -*- mode: LaTeX; compile-command: "cd ..; make compile" -*-

%if style == newcode
%include rae.fmt

\begin{code}

import Data.Kind

\end{code}

%endif

\chapter{Related work}
\label{cha:related}

There is a great deal of work related to this dissertation, looking at
designs of similar surface languages, designs of similar
intermediate languages, and similar type inference algorithms. This chapter
reviews this related work, starting with a thorough comparison with
the work of \citet{gundry-thesis}, which covers all of the areas above.

\section{Comparison to \citet{gundry-thesis}}

The most apt comparison of my work is to that of Gundry. His dissertation
is devoted to much the same goal as mine: adding dependent types to Haskell.
I have tried to compare my work to his as this has been topical throughout
this work. Here I summarize some of the key points of difference and explain
how my work expands upon what he has done.

\subsection{Unsaturated functions in types}

Gundry's intermediate language uses one element of the grammar to represent
both terms and types. But he offers separate typing judgments, as controlled
by his use of a phase modality. In Gundry's type system, every typing judgment
holds at one of three \emph{phases}:\footnote{Actually, one of four, but both
Gundry and I keep coercion typing so separate from other typing judgments
that I am excluding it here.} runtime, compile time, or shared (Gundry's 
Section 6.2). Gundry
describes an \emph{access policy} (Gundry's Section 6.2.1) whereby an
expression well-typed at the shared phase can also be used in either the
runtime or compile-time phases. Gundry's use of phases is not unlike my
use of relevance, where an expression well-typed at
Gundry's compile-time phase would be irrelevant in my formulation.

The big difference between my treatment and Gundry's is that I essentially
combine the shared and runtime phases. That is, anything that is allowed
at runtime is also allowed in types. Gundry prevents
$\lambda$-expressions and unsaturated functions from being used in types.
These constructs can be typed only at the runtime phase, never the shared
or compile-time phases. Because of this restriction around
unsaturated functions, Gundry's system must carefully track where unsaturated
functions appear and prevent any expression containing one from being used
in a type or a dependent context.

I avoid Gundry's restriction by tracking matchable functions separate
from unmatchable ones (Sections~\ref{sec:matchability} and~\ref{matchable-pico}).
This innovation permits me to allow unsaturated functions while
retaining the useful \ottkw{left} and \ottkw{right} coercions.
As a part of this aspect of my work, I also lift the matchable/unmatchable
distinction into surface Dependent Haskell, giving the user access to the
|!->|, |!pi|, and |!forall| quantifiers.

\subsection{Support for type families}

Both Gundry's and my treatments favor $\lambda$-abstractions and \ottkw{case}
expressions over type families. In my case, I would support type families
via compilation into those more primitive forms. Gundry's work, however,
explicitly does not support type families (Gundry's Section 6.7.4).
This lack of support is revealed
in two missing features:
\paragraph{Matching on |Type|} 
Through the way I have constructed my \ottkw{case} expressions---specifically,
treating |Type| as just another type constant---I allow
pattern-matching on elements of |Type|. Gundry's treatment requires a
scrutinee to be a member of a closed algebraic datatype.
\paragraph{Unsaturated matching}
Haskell type families can match on unsaturated uses of data and type
constructors, something not supported in Gundry's work but is supported
in \pico/.


\subsection{Axioms}

Gundry's \emph{evidence} language includes support for axioms. While the
notion of type-level axioms has been used in much prior work to represent
type families, Gundry uses them to represent notions beyond those possible
in type families, such as the commutativity of some primitive addition
operation. In order to set up his consistency proof, he needs to establish
that the axioms are \emph{good}, as defined in Gundry's Definition 6.4 of
his Section 6.5.1. Gundry does not provide an algorithm for determining
whether a set of axioms are \emph{good}, however.

\Pico/, in contrast, has no built-in support for axioms. One could try
adding axioms as global coercion variables available in every context, but
that would interfere with the current consistency proof (\pref{sec:consistency})
which severely limits the use of coercion variables. It is conceivable
that adding axioms to \pico/ is possible by establishing some condition,
like Gundry's \emph{good}, that claims that the axioms do not interfere
with consistency. This remains as future work, however.


\subsection{Type erasure}

Gundry proves a type erasure property similar to mine. However, there is
one key difference: my type erasure erases irrelevant abstractions (as does
today's implementation of System FC in GHC), while
Gundry's does not. It is not clear, however, that this change is significant,
in that it might easily be possible to tweak Gundry's system to allow erasure
of irrelevant abstractions, too.

\paragraph{}
See also \pref{sec:gundry-consistency-wrong} and \pref{sec:gundry-type-inference}
for further comments comparing my work to Gundry's.

\section{Comparison to Idris}

\subsection{Legacy support}
\subsection{Erasure}
\subsection{Type inference}
\subsection{Totality / reduction of non-terminating programs in types}
\subsection{Editor integration}

\section{Comparison to Cayenne}
\label{sec:cayenne}

Beyond Idris, there are many other languages one might want a comparison
against. The most frequent comparison I have been asked for, however,
is to compare against Cayenne~\cite{cayenne}, which I shall do here.

Cayenne is a language introduced in 1998 by Augustsson essentially as a
dependently typed variant of Haskell. Of particular interest,
it shares Dependent Haskell's
cavalier attitude toward termination: Cayenne supports general recursion
and all types are thus inhabited by $\bot$. As such, Augustsson admits
that Cayenne is not useful as a proof assistant. However, he also argues
that this admission does not mean it is useless as a programming language.
My argument in support of allowing general recursion in a dependently typed
language (\pref{sec:running-proofs}) broadly echoes Augustsson's Section 5,
claiming that a verification of partial correctness is better than no
verification at all.

Despite the similarities between my work here and Augustsson's, there are
a number of key differences:

\subsection{Type erasure}
Augustsson's approach to type erasure is much simpler than mine. Cayenne
erases all expressions of type |Type|---that's the full description
of type erasure in Cayenne. This simplistic view has two shortcomings,
however:
\begin{description}
\item[Cayenne erases too much] Because every expression of type |Type|
is lost, Cayenne must restrict its pattern-match facility not to work
over scrutinees of type |Type|. Dependent Haskell allows matching on |Type|,
in contrast.
\item[Cayenne erases too little] Sometimes expressions of a type other
than |Type| can be erased. For example, consider this function over length-indexed
vectors (\pref{sec:length-indexed-vectors}):
%if style == newcode
\begin{code}
data Nat = Zero | Succ Nat
data Vec :: Type -> Nat -> Type where
  Nil :: Vec a !Zero
  (:>) :: a -> Vec a n -> Vec a (!Succ n)
infixr 5 :>
\end{code}
%endif
\begin{code}
safeHead :: Vec a (!Succ n) -> a
safeHead (x :> _) = x
\end{code}
The |n| parameter to |safeHead| has type |Nat| and yet it can be erased in
the call to |safeHead|. Cayenne would have no way of erasing this parameter.
\end{description}

\subsection{Coercion assumptions}

Cayenne has no support for equality assumptions. This means that it does
not support GADTs (\pref{sec:gadts} or dependent pattern matching (\pref{sec:dependent-pattern-match}). Lacking these features significantly simplifies the
design of the language and implementation, meaning that many of the 
type inference issues (specifically, untouchability of type variables)
described by \citet{outsidein} are avoided. The lack of equality assumptions
also severely weakens Cayenne's ability to support intrinsic proofs---that
is, types whose structure ensure that all values of those types are valid
(like |Vec|, which ensures that the vector is of the given length). Cayenne
thus truly supports only extrinsic proofs: proofs written separately from
the functions and data structures they reason about. These proofs must be
written explicitly (intrinsic proofs are often encoded into the structure
of a function) and offer more opportunity to accidentally use a non-terminating
proof.

\subsection{A hierarchy of sorts}

Cayenne uses an infinite hierarchy of sorts, similar to many other
dependently typed languages, but in contrast to Dependent Haskell, with
its |Type : Type| axiom. Augustsson describes this design decision as
working in support of Cayenne's treatment as logical framework (if the
user takes on the burden of termination checking) as well as to support
Cayenne's implementation of type erasure.

\subsection{Metatheory}

While Augustsson presents typing rules for Cayenne, he offers no metatheory
analysis for Cayenne beyond proving that the evaluation of a type-erased
program simulates the evaluation of the original. Similarly, Augustsson
does not describe any type inference properties in detail. The language
requires top-level type annotations on all definitions, but inference is
still necessary to check a dependently typed expression. Instead, Augustsson
claims that ``Type signatures can be omitted in many places'' but does
not elaborate~\cite[fourth-to-last bullet in Section 3.2]{cayenne}.
Cayenne does syntactically require all function arguments to be annotated,
however.

\subsection{Modules}

Cayenne as a robust module system, more advanced than Haskell's. As such,
its module system is more advanced also than Dependent Haskell's. Cayenne
uses dependent records as its modules, as a dependent record can store
types as easily as other expressions. It remains as future work to see
whether or not Dependent Haskell can incorporate these ideas and use
records as modules.

\subsection{Conclusion}

As an early attempt to bring dependent types to Haskell, Cayenne deserves
much credit. Despite being declared dead in 2005\footnote{\url{http://lambda-the-ultimate.org/node/802}}, Haskellers still discuss this language. It may
have been the first thought-out vision of what a Haskell-like dependently
typed language would look like and thus serves as an inspiration for both
Agda and Idris.

\section{Comparison to Liquid Haskell}

\section{Invisibility in other languages}
\label{sec:vis-other-lang}

\begin{itemize}
%{
%format dbo = "\{\!\{"
%format dbc = "\}\!\}"
\item In Agda, an argument in single braces |{ ... }| is invisible and is
instantiated via unification. An argument in double braces |dbo ... dbc| is
invisible and is instantiated by looking for an in-scope variable of the
right type. One Agda encoding of, say, the |Show| class and its |Show Bool|
instance would be to make |Show| a record containing a |show| field (much
like GHC's dictionary for |Show|) and a top-level variable of type |Show Bool|.
The lookup process for |dbo ... dbc| arguments would then find this top-level
variable.

Thus, |show|'s type in Agda might look like |forall {a} -> dbo Show a dbc -> a ->
String|.
%}
%{
%format proof = "\keyword{proof}"
%format trivial = "\keyword{trivial}"
%format auto = "\keyword{auto}"
\item Idris supports type classes in much the same way as Haskell. A constraint
listed before a |(=>)| is solved just like a Haskell type class is. However,
other invisible arguments can also have custom solving tactics. An Idris
argument in single braces |{ ... }| is solved via unification, just like in
Agda. But a programmer may insert a proof script in the braces as well to
trigger that proof script whenever the invisible parameter needs to be
instantiated. For example, a type signature like
|func : {default proof { trivial } pf : tau } -> ...| names a (possibly-dependent)
parameter |pf|, of type |tau|. When |func| is called, Idris will run the
|trivial| tactic to solve for a value of type |tau|. This value will then
be inserted in for |pf|. Because a default proof script of |trivial| is so
common, Idris offers an abbreviation |auto| which means |default proof { trivial }|.
%}
\item
Coq has quite a different view of invisible arguments than do Dependent Haskell,
Agda, or Idris. In all three of those languages, the visibility of an argument
is part of a type. In Coq, top-level directives allow the programmer to change
the visibility of arguments to already-defined functions. For example, if we
have the definition
%{
%format Definition = "\keyword{Definition}"
%format Arguments = "\keyword{Arguments}"
%format Set = "\keyword{Set}"
%format Implicit = "\keyword{Implicit}"
%format mytrue1
%format mytrue2
%format forall = "\keyword{forall}"
\begin{spec}
Definition id A (x : A) := x.
\end{spec}
(without having used |Set Implicit Arguments|) both the |A| and |x| parameters
are visible. Thus the following line is accepted:
\begin{spec}
Definition mytrue1 := id bool true.
\end{spec}
However, we can now change the visibility of the arguments to |id| with the
directive
\begin{spec}
Arguments id {A} x.
\end{spec}
allowing the following to be accepted:
\begin{spec}
Definition mytrue2 := id true.
\end{spec}

Although Coq does not allow the programmer to specify an instantiation technique
for invisible arguments, it does allow the programmer to specify whether or
not invisible arguments should be \emph{maximally inserted}. A maximally
inserted invisible argument is instantiated whenever possible; a non-maximally
inserted argument is only instantiated when needed. For example, if the |A|
argument to |id| were invisible and maximally inserted, then any use of |id|
would immediately try to solve for |A|; if this were not possible, Coq would
report a type error. If |A| were not maximally inserted, than a use of |id|
would simply have the type |forall A, A -> A|, with no worry about invisible
argument instantiation.

The issue of maximal insertion in Dependent Haskell is solved via its
bidirectional type system (\pref{sec:bidirectional}). The subsumption relation
effectively ensures that the correct number of invisible parameters are provided,
depending on the context.
%}

\end{itemize}

\section{Applicability beyond Haskell}

\begin{proposal}
The knowledge gained in adding dependent types to Haskell will translate
to other environments as well. A key example will be the thought of adding
dependent types to a variant of ML. Going the other way, I will examine
adding more programmatic features to existing dependently typed languages
(in particular, Haskell's \keyword{newtype} construct).
\end{proposal}

\section{Future work}

\begin{proposal}
Though this dissertation will deliver $\Pi$, that's not the end of the story.
Here are some questions I have that I do not expect will be answered in the
course of writing this work.
\begin{itemize}
\item How to improve error messages? While my work will strive hard not to
degrade error messages for non-dependently-typed programs, I offer no
guarantee about the quality of error messages in programs with lots of
dependent types. How can these be improved? More generally, how can error
messages be customized by programmers to fit their domain?

\item What editor support is necessary to make dependent types in Haskell
practical?

\item Are there constructs that I have been unable to promote? How can these
be made to work in types?

\item How do we optimize a dependently typed program? Ideally, a program should
be optimized to the same level whether an argument is dependent or not. However,
optimizing $\Pi$-quantified arguments will amount to proving the optimizations
correct! How do we retain runtime performance in the face of dependent types?

\item How will dependent types interact with type-checker
  plugins~\cite{type-checker-plugins}? Can we use an SMT solver to make working
  with dependent types easier?

\item Dependent types will allow for proper dependent pairs ($\Sigma$-types).
  Is it worth introducing new syntax to support these useful constructs directly?

\item \rae{Pretty-printer plugin?}
\end{itemize}
\end{proposal}

\section{Type erasure in other languages}
\label{sec:related-type-erasure}

%%  LocalWords:  gundry newtype SMT
