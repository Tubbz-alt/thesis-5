%% -*- mode: LaTeX compile-command: "cd ..; make compile" -*-

%if style == newcode
%include rae.fmt
%endif

\chapter{\Pico/}
\label{cha:pico}

This chapter presents \pico/, the internal language Dependent Haskell compiles
into. I have proved type safety (via the usual preservation
and progress theorems, \pref{thm:preservation} and \pref{thm:progress})
and type erasure (\pref{thm:type-erasure} and \pref{thm:expr-eval}).
I believe \pico/ would make a strong candidate for the internal language
in a future version of GHC.

\section{Overview}

\Pico/ descends directly from the long line of work on System FC~\cite{systemfc}.
It is most closely related to the version of System FC presented in my prior
work~\cite{fckinds} and in Gundry's thesis~\cite{gundry-thesis}.

\Pico/
sits in the $\lambda$-cube~\cite{lambda-cube}
 on the same vertex as the Calculus of Constructions~\cite{coquand-cc}, but
with a very different notion of equality. A typical dependently typed
calculus contains a \emph{conversion} rule, something like this:
\[
\ottdrule{\ottpremise{\tau : \kappa_1 \qquad \kappa_1 \equiv \kappa_2}}{\tau : \kappa_2}{\rul{Conv}}
\]
This rule encapsulates the point of type equivalence: if a type $\tau$ is found
to have some kind $\kappa_1$ and $\kappa_1$ is known to be equivalent to
some $\kappa_2$, then we can say that $\tau$ has kind $\kappa_2$.\footnote{I tend
to use the word ``kind'' when referring to the classification of a type. However,
in the languages considered in this dissertation, kinds and types come from the
same grammar; the terms ``type'' and ``kind'' are technically equivalent.
Nevertheless, I find that discerning between these two words can aid intuition
and will continue to do so throughout the dissertation. \rae{Do I discuss elsewhere??}}
This rule is flexible and helps a language to be succinct. It has a major
drawback, however: it is not syntax directed. In general, determining
whether $\kappa_1 \equiv \kappa_2$ might not be easy. Indeed, type equivalence
in \pico/ is undecidable, so we would have a hard time building a type-checker
with a \rul{Conv} rule such as this one. Other dependently typed languages
are forced to restrict expressiveness in order to keep type-checking
decidable; this need for decidable type equivalence is one motivation to design
a dependently typed language to be strongly normalizing.

\Pico/'s approach to type equivalence (and the \rul{Conv} rule) derives from
the \emph{coercions} that provide the ``C'' in ``System FC''. Instead of relying
on a non-syntax-directed equivalence relation, \pico/'s type equivalence
requires evidence of equality in the form of coercions. Here is a simplified
version of \pico/'s take
of the \rul{Conv} rule:
\[
\ottdrule{\ottpremise{[[t]] : [[k1]] \qquad [[g]] : [[k1 [Type{}]~[Type{}] k2]]}}{[[t |> g]] : [[k2]]}{\rul{Ty\_Cast}}
\]
In this rule, the metavariable $[[g]]$ stands for a \emph{coercion}, a proof
of the equality between two types. Here, we see that $[[g]]$ proves that
kinds $[[k1]]$ and $[[k2]]$ are equivalent. Thus, we can type $[[t |> g]]$
at $[[k2]]$ as long as $[[t]]$ can be typed at $[[k1]]$. Note the critical
appearance of $[[g]]$ in the conclusion of the rule: this rule is syntax-directed.
The type-checker simply needs to check the equality proofs against a set of
(also syntax-directed) rules, not to check some more general equivalence relation.

The grammar for coercions (in~\pref{fig:coercions}) allows for a wide variety
of coercion forms, giving \pico/ a powerful notion of type equivalence.
However, this grammar includes no evaluation or proper $\lambda$-abstractions.\footnote{There is a coercion form that starts with $\lambda$; it is only a
congruence form for $\lambda$-abstractions in types, not a $\lambda$-abstraction
in the coercion language. See \pref{sec:lambda-coercion}.}
Thus, the fact that evaluation in \pico/ might not terminate does not threaten
the type safety of the language. Coercions are held separate from types,
and proving consistency of the coercion language (\pref{sec:consistency})---in
other words, that we cannot prove |Int ~ Bool|---is the heart of the
type safety proof. It does not, naturally, depend on any termination proof,
nor any termination checking of the program being checked. The independence
of \pico/'s type safety result from termination means that \pico/ can avoid
many potential traps that have snagged other dependently typed languages
that rely on intricate termination checks~\cite{...}.

\subsection{Features of \pico/}

\Pico/ is a dependently typed $\lambda$-calculus with algebraic datatypes and
a fixpoint operator. Recursion is modeled only via this fixpoint operator;
there is no recursive |let|. Other than the way in which the operational
semantics deals with coercions in the form of \emph{push rules}, the
small-step semantics is what you might expect for a call-by-name
$\lambda$-calculus.

The typing relations, however, have a few features worth mentioning up front:

\paragraph{Relevance annotations and type erasure}
A key concern when compiling a dependently typed language is type erasure.
Given that terms and types can intermingle, what should be erased during
compilation? And what data is necessary to be retained until runtime.
Dependent Haskell (and, in turn, \pico/) forces the user to specify this
detail at each quantifier (\pref{sec:relevance}). In the formal grammar
of \pico/, we distinguish between $[[PI]] [[a:Rel k]].\, ...$ and
$[[PI]] [[a:Irrel k]].\, ...$. The former is the type of an abstraction
that is retained at runtime, written with a |pi| in Haskell;
the latter abstraction, written with |forall| is fully erased.
In order to back up this claim of full erasure of irrelevant quantification,
evaluation happens under irrelevant abstractions; see \pref{sec:step-under-abs}.

So that we can be sure a variable's relevance is respected at use sites,
variable contexts $[[G]]$ track the relevance of bound variables. Only
relevant variables may appear in the ``level'' in which they were bound;
when a typing premise refers to a higher ``level'', the context is altered to
mark all variables as relevant. For example, the \ottkw{case} construct
$[[case_k t of alts]]$ includes the return kind of the entire \ottkw{case}
expression as its $[[k]]$ subscript. This kind is type-checked in a context
where all variables are marked as relevant; because the kind is erased
during compilation, the use of an irrelevant variable there is allowed.
As they are also erased, coercions are considered fully irrelevant as well.

My treatment of resetting the context is precisely like what is done
by \citet{erasure-pure-type-systems}.

\paragraph{Matching on partially-applied constants}
\Pico/ does not contain type families. Instead, it uses $\lambda$-abstractions
and \ottkw{case} expressions, as are more familiar to functional programmers.
And yet, I wish for \pico/ to support the variety of ways in which type families
are used in today's Haskell. One curiosity of today's Haskell is that it allows
matching on partially-applied data constructors:
\begin{code}
type family IsLeft a where
  IsLeft !Left  = !True
  IsLeft !Right = !False
\end{code}
The type family |IsLeft| is inferred to have kind
|forall k. (k -> Either k k) -> Bool|. That is, it matches on the |Left|
and |Right| constructors, even though these are not applied to arguments.
While it may seem that |IsLeft| is matching on a \emph{function}---after all,
the type of |IsLeft|'s argument appears to be an arrow type---it is not.
It is matching only on constructors, because the kind-level |->| classifies
only type constants. \rae{Flesh this out once I know how I'm dealing with the
two arrows in Haskell.}

To get this partially-applied matching to work in \pico/, it is necessary
to have two different $[[PI]]$-quantifiers: $[[MPI]]$ and $[[UPI]]$. The
former is called a \emph{matchable} $[[PI]]$, the latter is \emph{unmatchable}.
Type constants are classified by $[[MPI]]$, whereas $\lambda$-abstractions
are classified by $[[UPI]]$.
Only matchable $[[MPI]]$-types are allowed as \ottkw{case} scrutinees.
When I write the unadorned $[[PI]]$, I actually mean a metavariable which
might be instantiated either to $[[MPI]]$ or $[[UPI]]$.

\paragraph{Matching on $[[Type]]$}

Today's Haskell also has the ability, through its type families, to match on
members of $[[Type]]$. For example:
\begin{code}
type family IntLike x where
  IntLike Integer = !True
  IntLike Int     = !True
  IntLike _       = !False
\end{code}
This ability for a function to inspect the choice of a type---and not a code
for a type---is unique to Haskell, as far as I am aware. With the type families
in today's Haskell, discerning between types is done by simple pattern matching.
However, if we compile type families to \ottkw{case} statements, we need a way
to deal with this construct.

Fortunately, types like |Either| resemble data constructors like |Just|:
both are classified by matchable quantification(s) over a type headed by another
type constant. In the case of |Either|, we have $|Either| : 
[[MPI _:Rel Type{}, _:Rel Type{}. Type{} ]]$;\footnote{Why $[[Rel]]$? See
\pref{sec:relevance-of-datatypes}.} note that the body of the
$[[PI]]$-type is headed by the constant $[[Type{}]]$. For |Just|,
we have $|Just|_{[[ {a} ]]} : [[MPI _ :Rel a. Maybe{} a]]$.\footnote{The
$[[ {a} ]]$ subscript is explain in \pref{sec:universals}.}
With this similarity, it is not hard to create a typing rule for a \ottkw{case}
statement that can handle both data constructors (like |Just|) and types
(like |Either|).

A key feature, however, that is needed to support matching on $[[Type]]$ is
default patterns. For a closed datatype, where all the constructors can be
enumerated, default patterns are merely a convenience; any default can be
expanded to list all possible constructors. For an open type, like $[[Type]]$,
the availability of the default pattern is essential. It is for this reason alone
that I have chosen to include default patterns in \pico/.

\subsection{Design requirements for \pico/}

In the course of any language design, there needs to be a guiding principle
to aid in making free design decisions. The chief motivator for the design
of \pico/ is that it should be suitable for use as the internal language
of a Haskell compiler. This use case provides several desiderata:

\paragraph{Decidable, syntax-directed, efficient type-checking}
The use of types in a compiler's intermediate language serves only as a check
of the correctness of the compiler. Any programmer errors are caught before
the intermediate language code is emitted, and so a correct compiler should
only produce well-typed intermediate-language programs, if it produces such
programs at all. In addition, a correct compiler performing program transformations
on the intermediate language should take a well-typed program to a well-typed
program. However, not all compilers are correct, and thus it is helpful
to have a way to check that intermediate-language program generation and
transformation is at least type-preserving. To check this property, we need
to type-check the intermediate language, both after it is originally
produced and after every transformation. It thus must be easy and efficient
to do so.

\Pico/ essentially encodes a typing derivation right in the syntax of types
and coercions. It is thus very easy to write a type-checker for the language.
Type-checking is manifestly decidable and can be done in one pass over the
program text, with no constraint solving.\footnote{I do not claim that it
is strictly linear, as a formal analysis of its running time is beyond the
scope of this dissertation. In particular, one rule
(see \pref{sec:case-expressions}) requires the use of a unification algorithm
and likely breaks linearity.} \Pico/'s lack of a termination requirement
also significantly lowers the burden of implementation of a type-checker
for the language.

\paragraph{Erasability}

An intermediate-language program should make clear what information can be
erased at runtime. After all, when the compiler is done performing optimizations,
runtime code generation must take place, and we thus need to know what
information can be dropped. It is for this reason that \pico/ includes the
relevance annotations.

\subsection{Other applications of \pico/}

It is my hope that \pico/ sees application beyond just in Haskell. In designing
it, I have tried to permit certain Haskell idioms (call-by-name semantics,
the extra capabilities of \ottkw{case} expressions outlined above) while
still retaining a general enough flavor that it could be adapted to other
settings. I believe that the arguments above about \pico/'s design mean
that it is a suitable starting-point for the design of an
intermediate language for any dependently typed surface language. Other uses
might want call-by-value instead of call-by-name or to remove the somewhat
fiddly distinction between $[[MPI]]$ and $[[UPI]]$. These changes should be
rather straightforward to make.

In certain areas, I have decided not to support certain existing Haskell
constructs directly in \pico/ because doing so would clutter the language,
making its applicability beyond Haskell harder to envision. Various
extensions of \pico/---which would likely appear in an implementation of
\pico/ within GHC---are discussed in \pref{sec:pico-extensions}. These
include representation polymorphism and support for the $([[->]])$ type 
constructor, for example.

\subsection{No roles in \pico/}

Recent versions of System FC have included \emph{roles}~\cite{coercible},
which distinguish between two different notions of type equality:
nominal equality is the equality relation embodied in Haskell's |(~)|
operator, whereas representational equality relates types that have
bit-for-bit identical runtime representations. Tracking these two
equality relations is important for allowing zero-cost conversions
between types known to have the same representation, and it is an
important feature to boost performance of programs that use |newtype|
to enforce abstraction.

However, roles greatly clutter the language
and its proofs. Including them throughout this dissertation would distract
us from the main goal of understanding a dependently typed language
with $[[Type{}]] : [[Type{}]]$ and
at ease with non-termination. It is for this reason that I have chosen
to omit roles entirely from this work. I am confident that, in time, roles
can be integrated with the language presented here, perhaps along the
lines I have articulated in a draft paper~\cite{overabundance-of-equalities},
though the treatment there still leaves something to be desired.
Regardless of clutter, having a solid approach to combining roles with
dependent types will be a prerequisite of releasing a performant
implementation of dependent types in GHC.

\section{Grammar}

\begin{figure}
Metavariables:
\[
\begin{array}{rl@@{\qquad}rl}
[[T]] & \text{algebraic datatype} & [[K]] & \text{data constructor} \\
[[a,b,x]] & \text{type/term variable} & [[c]] & \text{coercion variable} \\
[[i, j, kk, n]] & \text{natural number/index}
\end{array}
\]
\[
\begin{array}{rcl@@{\quad}l}
[[PI]] &\bnfeq& [[MPI]] & \text{matchable dep.~quantifier} \\
&\bnfor& [[UPI]] & \text{unmatchable dep.~quantifier} \\
[[z]] &\bnfeq& [[a]] \bnfor [[c]] & \text{type or coercion variable} \\
[[H]] &\bnfeq& [[T]] \bnfor [[K]] \bnfor [[Type]] & \text{constant} \\
[[rel]] &\bnfeq& [[Rel]] \bnfor [[Irrel]] & \text{relevance annotation} \\
[[d]] &\bnfeq& [[a :rel k]] \bnfor [[c : phi]] & \text{binder} \\
[[phi]] &\bnfeq& [[t1 (k1)~(k2) t2]] & \text{heterogeneous equality} \\
[[t, s, k]] &\bnfeq& [[a]] \bnfor [[t p]] \bnfor [[PI d.t]] \bnfor [[\d.t]] 
                   & \text{dependent types} \\
&\bnfor& [[H{ts}]] & \text{constant applied to universals} \\
&\bnfor& [[t |> g]] & \text{kind cast} \\
&\bnfor& [[case_k t of alts]] & \text{case-splitting} \\
&\bnfor& [[fix t]] & \text{recursion} \\
&\bnfor& [[absurd g t]] & \text{absurdity elimination} \\
[[p]] &\bnfeq& [[t]] \bnfor [[{t}]] \bnfor [[g]] & \text{argument} \\
[[alt]] &\bnfeq& [[pat -> t]] & \text{case alternative} \\
[[pat]] &\bnfeq& [[H]] \bnfor [[_]] & \text{pattern} \\
[[g,h]] &\bnfeq& [[c]] & \text{coercion assumption} \\
&\bnfor& [[<t>]] \bnfor [[sym g]] \bnfor [[g1 ;; g2]] & \text{equivalence} \\
&\bnfor& [[H{gs}]] \bnfor [[g w]] \bnfor [[PI a:rel h.g]] \bnfor [[PI c:(h1,h2).g]]   & \text{congruence} \\
&\bnfor& \multicolumn{2}{l}{[[case_h g of calts]] \bnfor [[fix g]]
\bnfor [[\a :rel h.g]] \bnfor [[\c:(h1,h2).g]]  
\bnfor [[absurd (h1,h2) g]]} \\
&\bnfor& [[t1 ~={h} t2]] & \text{coherence} \\
&\bnfor& [[argk g]] \bnfor [[argk n g]] \bnfor [[res^n g]] \bnfor [[g@w]] & \text{$[[PI]]$-type decomposition} \\
&\bnfor& [[nth n g]] & \text{injectivity} \\
&\bnfor& [[kind g]] & \text{``John Major'' equality} \\
&\bnfor& [[step t]] & \text{$\beta$-equivalence} \\
[[calt]] &\bnfeq& [[pat -> g]] & \text{case alternative in coercion} \\
[[w]] &\bnfeq& [[g]] \bnfor [[{g}]] \bnfor [[(g1,g2)]] & \text{coercion argument} \\[1ex]
[[S]] &\bnfeq& [[empty]]  & \text{signature} \\
&\bnfor& [[S, T:(as:ks)]] & \text{algebraic datatype} \\
&\bnfor& [[S, K:(D;T)]] & \text{data constructor} \\
[[G,D]] &\bnfeq& [[empty]] \bnfor [[G, d]] & \text{context/telescope} \\
[[theta]] &\bnfeq& [[empty]] \bnfor [[theta, t/a]] \bnfor [[theta, g/c]] & \text{substitution} \\[1ex]
[[e]] &\bnfeq& [[a]] \bnfor [[H]] \bnfor [[e y]] \bnfor [[PI]] \bnfor [[case e of ealts]] & \text{erased expression} \\
& \bnfor & [[\a.e]] \bnfor [[\o.e]] \bnfor [[fix e]] \\
[[y]] &\bnfeq& [[e]] \bnfor [[o]] & \text{erased argument} \\
[[ealt]] &\bnfeq& [[pat -> e]] & \text{erased alternative} \\
\end{array}
\]
\caption{The grammar of \pico/}
\label{fig:pico-grammar}
\end{figure}

\begin{figure}
\[
\begin{array}{rcl}
\overline{\;} &\defeq& \text{(an overbar) indicates a list} \\
[[_]] &\defeq& \text{a fresh variable whose name is not used} \\
[[dom(D)]] &\defeq& \text{the list of variables bound in $[[D]]$} \\
[[prefix]](\cdot) &\defeq& \text{a prefix of a list; length specified elsewhere} \\
[[fv]](\cdot) &\defeq& \text{extract all free variables, as a set} \\
[[H]] &\defeq& [[H{blank}]] \text{ (when appearing in a type)} \\
[[PI D. t]] &\defeq& \text{nested $[[PI]]$s} \\
[[MUPI D. t]] &\defeq& \text{nested $[[PI]]$s, where the individual $[[PI]]$s used might differ} \\
[[\D.t]] &\defeq& \text{nested $[[\ ]]$s} \\
[[t1 [k1]~[k2] t2]] &\defeq& [[t1 (k1)~(k2) t2]] \text{ (when the kinds are obvious or unimportant)} \\
[[o]] &\defeq& \text{an erased coercion} \\
[[#]] &\defeq& \text{the sets of free variables of two entities are distinct} \\
\lfloor \cdot \rfloor &\defeq& \text{coercion erasure (\pref{sec:coercion-erasure})} \\
\llfloor \cdot \rrfloor &\defeq& \text{type erasure (\pref{sec:type-erasure})} \\
\ottkw{let} &\text{is}& \text{used in the metatheory only and should be eagerly expanded}\\

\caption{Notation conventions of \pico/}
\label{fig:pico-notation}
\end{figure}

The full grammar of \pico/ appears in \pref{fig:pico-grammar} and
notation conventions appear in \pref{fig:pico-notation}. Later
sections of this chapter will cover portions of the typing rules, but for
a full listing of all the typing rules of the language, please see
\pref{app:pico}.

\rae{Must introduce $[[ee]]$ when appropriate.}

\rae{Extensions: split, |Equals|, representation polymorphism, |(->)|, compression (\ottkw{step} becoming $\ottkw{step}]^n$).}
