%% Semantics for FCD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Consistency  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JCons :: '' ::=

defn
t1 ! t2 :: :: Cons :: 'C_'
  {{ com Type consistency }}
by

t1 is not a value
------- :: NonValue1
t1 ! t2

t2 is not a value
------- :: NonValue2
t1 ! t2

------- :: TyCon
H[ts] ss ! H[ts'] ss'

%% Why don't combine these next two? Because we need the relevances
%% to be the same.

------------------------------ :: PiTy
PI a:rel k. t ! PI a:rel k'.t'

------------------------- :: PiCo
PI c:phi.t ! PI c:phi'.t'

% I think this rule is just needed for reflexivity.
------------- :: Lam
\d.t ! \d'.t'


% defn
% ee1 !! ee2 :: :: ECons :: 'EC_'
%   {{ com Erased type consistency }}
% by

% ------- :: TyCon
% H** ss !! H** ss'

% %% Why don't combine these next two? Because we need the relevances
% %% to be the same.

% ------------------------------ :: PiTy
% PI a:rel k. t !! PI a:rel k'.t'

% ------------------------- :: PiCo
% PI o:phi.t !! PI o:phi'.t'

% % I think this rule is just needed for reflexivity.
% ------------- :: Lam
% \d.t !! \d'.t'


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Type constants  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JTyCon :: '' ::=

defn
S |-tc H : D1 ; D2 ; H' :: :: Tc :: 'Tc_'
  {{ com Type constant kinds, with universals [[D1]], existentials [[D2]], and result [[H']] }}
by

T : (as:ks) \in S
------------ :: ADT
S |-tc T : empty; as:Rel ks; Type

K : (D; T) \in S  // T : (as:ks) \in S
----------------------------- :: DataCon
S |-tc K : as:Irrel ks; D; T

--------------- :: Type
S |-tc Type : empty; empty; Type

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Types  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JTy :: '' ::=

defn
S ; G |-ty t : k :: :: Ty :: 'Ty_'
  {{ com Type formation }}
by

S |-ctx G  //  a :Rel k \in G
-------------- :: Var
S;G |-ty a : k

S |-tc H : D1;D2;H'  //  S |-ctx G
S;G |-vec ts : D1
-------------- :: Con
S;G |-ty H[ts] : MPI D2[ts/dom(D1)]. H'[] ts

S;G |-ty t1 : PI a :Rel k1. k2  //  S;G |-ty t2 : k1
------------------ :: AppRel
S;G |-ty t1 t2 : k2[t2/a]

S;G |-ty t1 : PI a :Irrel k1. k2  //  S;Rel(G) |-ty t2 : k1
------------------ :: AppIrrel
S;G |-ty t1 t2 : k2[t2/a]

S;G |-ty t : PI c : phi. k //  S;Rel(G) |-co g : phi
------------------ :: CApp
S;G |-ty t g : k[g/c]

S;G, Rel(d) |-ty k : Type[]
-------------------------------- :: Pi
S;G |-ty PI d. k : Type[]

S;Rel(G) |-co g : k1 ~ k2
S;G |-ty t : k1   //  S;Rel(G) |-ty k2 : Type[]
-------------------- :: Cast
S;G |-ty t |> g : k2

S;Rel(G) |-co g : t1 ~ t2
S;Rel(G) |-ty t1 : k1 // S;Rel(G) |-ty t2 : k2
---------------------------- :: Coercion
S;G |-ty g : (~)[] k1 k2 t1 t2

S;Rel(G) |-ty k : Type[]  //  S;G |-ty t : H[] ss
forall i: S;G;H[] ss;t |-alt alti : k
alts are exhaustive for H
------------------------------ :: Case
S;G |-ty case_k t of alts : k

S;G,d |-ty t : k  //  d = a:rel s
------------------------ :: Lam
S;G |-ty \d.t : UPI d. k

S;G |-ty t : UPI _:Rel k.k   //  k = UPI a:rel k1.k2
------------------ :: Fix
S;G |-ty fix t : k

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Case  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S ; G ; s ; t |-alt alt : k :: :: Alt :: 'Alt_'
  {{ com Case alternatives }}
  {{ tex [[S]];[[G]];[[s]] [[|-alt]]^{\!\!\!\raisebox{.1ex}{$\scriptstyle [[t]]$} } [[alt]] : [[k]] }}
by

S |-tc H : D1;D2;H'
D0 = prefix(D2)  // zs = dom(D0)
S;G,D0[ss/dom(D1)],c: t0 ~ H[ss] zs |-ty t : k0
-------------------------------- :: Match
S;G;H'[] ss;t0 |-alt H zs -> c. t : k0

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Coercions  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S ; G |-co g : phi :: :: Co :: 'Co_'
  {{ com Coercion formation }}
by

S |-ctx G  //  c : phi \in G
------------------ :: Var
S;G |-co c : phi

S;G |-ty t : k
-------------------- :: Refl
S;G |-co <t> : t ~ t

S;G |-co g : t1 ~ t2
------------------------ :: Sym
S;G |-co sym g : t2 ~ t1

S;G |-co g1 : t1 ~ t2
S;G |-co g2 : t2 ~ t3
-------------------------- :: Trans
S;G |-co g1 ;; g2 : t1 ~ t3

S;G |-co h : k1 ~ k2  // |t1| = |t2|
S;G |-ty t1 : k1  //  S;G |-ty t2 : k2
-------------------------------- :: Coherence
S;G |-co erase_h t1 t2 : t1 ~ t2

S;G |-co g1 : t1 ~ s1
S;G |-co g2 : t2 ~ s2
S;G |-ty t1 t2 : k1 // S;G |-ty s1 s2 : k2
-------------------------- :: App
S;G |-co g1 g2 : t1 t2 ~ s1 s2

S;G |-co h : k1 ~ k2
S;G,a:rel k1 |-co g : s1 ~ s2
-------------------------------- :: PiTy
S;G |-co PI a :rel h. g : PI a:rel k1.s1 ~ PI a:rel k2.(s2[a |> sym h/a])

S;G |-co h : phi1 ~ phi2
S;G,c:phi1 |-co g : s1 ~ s2
h1 = nth 3 h  //  h2 = nth 4 h
% h : (t1 ~ t2) ~ (k1 ~ k2)
% h1 : t1 ~ k1
% h2 : t2 ~ k2
% phi1 = t1 ~ t2
% phi2 = k1 ~ k2
% c:phi2 |- h1 ;; c ;; sym h2 : t1 ~ t2
-------------------------------- :: PiCo
S;G |-co PI c : h. g : PI c:phi1.s1 ~ PI c:phi2.(s2[h1 ;; c ;; sym h2 / c])

S;G |-prop phi  //  S;G |-co g : t1 ~ t2
S;G |-ty t1 : H[] ss1   //  calts are exhaustive for H
forall i: S;G;H[] ss1;t1 |-calt calti : phi
------------------------------ :: Case
S;G |-co case_phi g of calts : phi

S;G |-co h : k1 ~ k2
S;G, a :rel k1 |-co g : t1 ~ t2
------------------------------------- :: Lam
S;G |-co \a :rel h . g : \a:rel k1.t1 ~ \a:rel k2.(t2[a |> sym h/a])

S;G |-co g : t1 ~ t2
-------------------------------- :: Fix
S;G |-co fix g : fix t1 ~ fix t2

S;G |-co g : PI a:rel k1. s1 ~ PI a:rel k2. s2
------------------------- :: ArgK
S;G |-co argk g : k1 ~ k2

S;G |-co g : PI c:phi1.s1 ~ PI c:phi2.s2
-------------------------------- :: CArgK
S;G |-co argk g : phi1 ~ phi2

S;G |-co g : \a:rel k1.s1 ~ \a:rel k2.s2
------------------------- :: ArgKLam
S;G |-co argk g : k1 ~ k2

S;G |-co g : PI a:Rel k1. s1 ~ PI a:Rel k2. s2
S;G |-co h : t1 ~ t2
S;G |-ty t1 : k1  //  S;G |-ty t2 : k2
-------------------------- :: InstRel
S;G |-co g@h : s1[t1/a] ~ s2[t2/a]

S;G |-co g : PI a:Irrel k1. s1 ~ PI a:Irrel k2. s2
S;Rel(G) |-co h : t1 ~ t2
S;Rel(G) |-ty t1 : k1  //  S;Rel(G) |-ty t2 : k2
---------------------------------- :: InstIrrel
S;G |-co g@h : s1[t1/a] ~ s2[t2/a]

S;G |-co h1 : PI c:phi1. s1 ~ PI c:phi2.s2
S;G |-co h2 : g1 ~ g2
S;G |-co g1 : phi1  //   S;G |-co g2 : phi2
-------------------------- :: CInst
S;G |-co h1@h2 : s1[g1/c] ~ s2[g2/c]

S;G |-co g : \a:rel k1.t1 ~ \a:rel k2.t2
S;G |-co h : s1 ~ s2
S;G |-ty s1 : k1  //  S;G |-ty s2 : k2
--------------------------- :: InstLam
S;G |-co g@h : t1[s1/a] ~ t2[s2/a]

S;G |-co g : H[ks] ts ~ H[ks'] ss
-------------------------- :: Nth
S;G |-co nth i g : ti ~ si

S;G |-co g : t1 ~ t2
S;G |-ty t1 : k1  //  S;G |-ty t2 : k2
------------------------- :: Kind
S;G |-co kind g : k1 ~ k2

S;G |-ty t : k   //  S;G |-s t --> t'
------------------------ :: Step
S;G |-co step t : t ~ t'

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Coercion case alternatives  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S ; G ; s ; t |-calt calt : phi :: :: CAlt :: 'CAlt_'
  {{ com Case alternative in a coercion }}
  {{ tex [[S]];[[G]];[[s]] [[|-calt]]^{\!\!\!\raisebox{.1ex}{$\scriptstyle [[t]]$} } [[calt]] : [[phi]] }}
by

S |-tc H : D1;D2;H'
D0 = prefix(D2)  //  zs = dom(D0)
S;G,D0[ss/dom(D1)],c: t0 ~ H[ss] zs |-co g : k1 ~ k2
-------------------------------------- :: Match
S;G;H'[] ss;t0 |-calt H zs -> c. g : k1 ~ k2

% in RHS:
% nth i h : s1i ~ s2i

% c : t2 ~ H[ss2] zs
% must prove t1 ~ H[ss1] zs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Propositions  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S ; G |-prop phi :: :: Prop :: 'Prop_'
  {{ com Proposition formation }}
by

S;G |-ty t1 : k1
S;G |-ty t2 : k2
------------------ :: Equality
S;G |-prop t1 ~ t2


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Vectors  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S ; G |-vec ts : D :: :: Vec :: 'Vec_'
  {{ com Type vector formation }}
by

S |-ctx G
----------------------- :: Nil
S;G |-vec empty : empty

S;G |-ty t : k
S;G |-vec ss : D[t/a]
-------------------------- :: TyRel
S;G |-vec t,ss : a:Rel k,D

S;Rel(G) |-ty t : k
S;G |-vec ss : D[t/a]
-------------------------- :: TyIrrel
S;G |-vec t,ss : a:Irrel k,D

S;Rel(G) |-co g : phi
S;G |-vec ss : D[g/c]
------------------------ :: Co
S;G |-vec g,ss : c:phi,D


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Telescopes  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S ; G |-tel D :: :: Tel :: 'Tel_'
  {{ com Telescope formation }}
by

S |-ctx G,D
----------- :: Binders
S;G |-tel D

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Signatures  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
|-sig S :: :: Sig :: 'Sig_'
  {{ com Signature formation }}
by

----------- :: Nil
|-sig S0

S; empty |-tel as :Irrel ks  // T # S
----------------- :: ADT
|-sig S, T : (as:ks)

T : (as:ks) \in S   //  S;as:Irrel ks |-tel D  // K # S
------------------- :: DataCon
|-sig S, K : (D; T)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Contexts  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S |-ctx G :: :: Ctx :: 'Ctx_'
  {{ com Context formation }}
by

|-sig S
-------------- :: Nil
S |-ctx empty

S;Rel(G) |-ty k : Type[]  //  a # G  //  S |-ctx G
-------------- :: TyVar
S |-ctx G, a:rel k

S;Rel(G) |-prop phi  // c # G   // S |-ctx G
---------------- :: CoVar
S |-ctx G, c:phi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Reduction  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JStep :: '' ::=

defn
S ; G |-s s --> s' :: :: Step :: 'S_'
  {{ com Small-step operational semantics }}
by

------------------------- :: Beta
S;G |-s (\a:rel k.s1) s2 --> s1[s2/a]

alti = H zs -> c. t0  // other alternatives do not match H
---------------------------- :: Match
S;G |-s case_k H[ts] ss of alts --> t0[ss/zs,<H[ts] ss>/c]

t = \a:rel k.s
---------------------------- :: Unroll
S;G |-s fix t --> s[fix t/a]

---------------------------------- :: Trans
S;G |-s (v |> g1) |> g2 --> v |> (g1 ;; g2)

S;G,a:Irrel k |-s s --> s'
------------------------------------- :: IrrelAbs_Cong
S;G |-s \a :Irrel k.s --> \a :Irrel k. s'

S;G |-s s1 --> s1'
---------------- :: App_Cong
S;G |-s s1 s2 --> s1' s2

S;G |-s s --> s'
------------------ :: Cast_Cong
S;G |-s s |> g --> s' |> g

S;G |-s s --> s'
-------------------------------------- :: Case_Cong
S;G |-s case_t s of alts --> case_t s' of alts

S;G |-s t --> t'
------------------------ :: Fix_Cong
S;G |-s fix t --> fix t'

S;G |-ty v : PI a:rel k. s
g1 = sym (argk g0)      //   g2 = g0@(erase_(sym g1) (t |> g1) t)
% g0 : PI a:rel k. s ~ PI a:rel k'. s'
% g1 : k' ~ k
% g2 : s[(t |> g1)/a] ~ s'[t/a]
----------------------------------------- :: Push
S;G |-s (v |> g0) t --> v (t |> g1) |> g2

S;G |-ty v : PI c:phi. s
g1 = argk g0 //  g2 = nth 2 g1  //  g3 = sym (nth 3 g1)
h' = g2 ;; h ;; g3  //  g4 = g0@(erase_g1 h' h)
% g0 : PI c:phi.s ~ PI c:phi'.s'
% phi = t1 ~ t2
% phi' = t1' ~ t2'
% h : t1' ~ t2'
% g2 : t1 ~ t1'
% g3 : t2' ~ t2
% g4 : s[(g1 ;; h ;; g2)/c] ~ s'[h/c]
% h' : (g1 ;; h ;; g2) ~ h
% g1 : phi ~ phi'
--------------------------------------------- :: CPush
S;G |-s (v |> g0) h --> v h' |> g4

----------------------------------- :: APush
S;G |-s \a :Irrel k. (v |> g) --> (\a :Irrel k. v) |> (UPI a:Irrel <k>. g)

S |-tc H : as:Irrel ks;D;H'
S;G |-co h : H'[] ts ~ H'[] ts'
forall i: gi = build_kpush_co(<k>@(nths h);ss_{0..i-1})
forall i: si' = si |> argk gi
% kind K = MPI as :Irrel ks. MPI D. T as
% si' = s' |> argk (kind K @ nths h @ ...)
----------------------------------------------------------------- :: KPush
S;G |-s case_k0 (H[ts] ss) |> h of alts --> case_k0 H[ts'] ss' of alts

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Parallel reduction  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JRed :: '' ::=

defn
t ~> t' :: :: Red :: 'R_'
  {{ com Type parallel reduction, over erased types }}
by

-------------- :: Refl
t ~> t

t ~> t' // s ~> s'
-------------------- :: App
t s ~> t s'

d ~> d'   //  t ~> t'
---------------------------------------- :: Pi
PI d. t ~> PI d'. t'

k ~> k'  //  t ~> t'
forall i: alti ~> alti'
---------------- :: Case
case_k t of alts ~> case_k' t' of alts'

d ~> d'  // t ~> t'
-------------- :: Lam
\d.t ~> \d'.t'

t ~> t'
--------------- :: Fix
fix t ~> fix t'

t1 ~> t1'  // t2 ~> t2'
------------------------------ :: Beta
(\a :rel k. t1) t2 ~> t1'[t2'/a]

alti = H zs -> o. t0  // ss ~> ss' // t0 ~> t0'
other alternatives do not match H
----------------------------------- :: Match
case_k H** ss of alts ~> t0'[ss'/zs]

s ~> s' // k ~> k'
------------------- :: Unroll
fix (\a:rel k.s) ~> s'[fix (\a:rel k'.s')/a]

defn
d ~> d' :: :: RedBnd :: 'R_'
  {{ com Parallel reduction of binder }}
by

k ~> k'
--------------------- :: TyBinder
a :rel k ~> a :rel k'

s1 ~> s2 // t1 ~> t2
---------- :: CoBinder
o:s1 ~ t1 ~> o:s2 ~ t2

defn
alt ~> alt' :: :: RedAlt :: 'R_'
  {{ com Parallel reduction in case alternative }}
by

t ~> t'
------------------------- :: Alt
(p -> o. t) ~> (p -> o. t')
