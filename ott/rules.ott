%% Semantics for FCD

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Consistency  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JCons :: '' ::=

defn
t1 ! t2 :: :: Cons :: 'C_'
  {{ com Type consistency }}
by

t1 is not a value
------- :: NonValue1
t1 ! t2

t2 is not a value
------- :: NonValue2
t1 ! t2

------- :: TyCon
H{ts} ps ! H{ts'} ps'

%% Why don't combine these next two? Because we need the relevances
%% to be the same.

------------------------------ :: PiTy
PI a:rel k. t ! PI a:rel k'.t'

------------------------- :: PiCo
PI c:phi.t ! PI c:phi'.t'

% I think this rule is just needed for reflexivity.
------------- :: Lam
\d.t ! \d'.t'


% defn
% ee1 !! ee2 :: :: ECons :: 'EC_'
%   {{ com Erased type consistency }}
% by

% ------- :: TyCon
% H** ss !! H** ss'

% %% Why don't combine these next two? Because we need the relevances
% %% to be the same.

% ------------------------------ :: PiTy
% PI a:rel k. t !! PI a:rel k'.t'

% ------------------------- :: PiCo
% PI o:phi.t !! PI o:phi'.t'

% % I think this rule is just needed for reflexivity.
% ------------- :: Lam
% \d.t !! \d'.t'


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Type constants  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JTyCon :: '' ::=

defn
S |-tc H : D1 ; D2 ; H' :: :: Tc :: 'Tc_'
  {{ com Type constant kinds, with universals [[D1]], existentials [[D2]], and result [[H']] }}
by

T : (as:ks) \in S
------------ :: ADT
S |-tc T : empty; as:Rel ks; Type

K : (D; T) \in S  // T : (as:ks) \in S
----------------------------- :: DataCon
S |-tc K : as:Irrel ks; D; T

--------------- :: Type
S |-tc Type : empty; empty; Type

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Types  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JTy :: '' ::=

defn
S ; G |-ty t : k :: :: Ty :: 'Ty_'
  {{ com Type formation }}
by

S |-ctx G  //  a :Rel k \in G
-------------- :: Var
S;G |-ty a : k

S |-tc H : D1;D2;H'  //  S |-ctx G
S;Rel(G) |-vec ts : D1
-------------- :: Con
S;G |-ty H{ts} : MPI (D2[ts/dom(D1)]). H'{} ts

S;G |-ty t1 : PI a :Rel k1. k2  //  S;G |-ty t2 : k1
------------------ :: AppRel
S;G |-ty t1 t2 : k2[t2/a]

S;G |-ty t1 : PI a :Irrel k1. k2  //  S;Rel(G) |-ty t2 : k1
------------------ :: AppIrrel
S;G |-ty t1 {t2} : k2[t2/a]

S;G |-ty t : PI c : phi. k //  S;Rel(G) |-co g : phi
------------------ :: CApp
S;G |-ty t g : k[g/c]

S;G, Rel(d) |-ty k : Type{}
-------------------------------- :: Pi
S;G |-ty PI d. k : Type{}

S;Rel(G) |-co g : k1 ~ k2
S;G |-ty t : k1   //  S;Rel(G) |-ty k2 : Type{}
-------------------- :: Cast
S;G |-ty t |> g : k2

S;Rel(G) |-ty k : Type{}  //  S;G |-ty t : s
forall i: S;G;s;t |-alt alti : k
s = MPI D. H{} ss // alts are exhaustive for H
------------------------------ :: Case
S;G |-ty case_k t of alts : k

S;G,d |-ty t : k
------------------------ :: Lam
S;G |-ty \d.t : UPI d. k

S;G |-ty t : UPI _:Rel k.k   //  k = UPI a:rel k1.k2
------------------ :: Fix
S;G |-ty fix t : k

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Case  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S ; G ; s ; t |-alt alt : k :: :: Alt :: 'Alt_'
  {{ com Case alternatives }}
  {{ tex [[S]];[[G]];[[s]] [[|-alt]]^{\!\!\!\raisebox{.1ex}{$\scriptstyle [[t]]$} } [[alt]] : [[k]] }}
by

S |-tc H : D1;D2;H'  //  D0,D' = D2[ss/dom(D1)]
S;G |-ty t : UPI D0, c: t0 ~ H{ss} dom(D0). k
-------------------------- :: Match
S;G;MPI D'.H'{} ss;t0 |-alt H -> t : k

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Coercions  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S ; G |-co g : phi :: :: Co :: 'Co_'
  {{ com Coercion formation }}
by

S |-ctx G  //  c : phi \in G
------------------ :: Var
S;G |-co c : phi

S;G |-ty t : k
-------------------- :: Refl
S;G |-co <t> : t ~ t

S;G |-co g : t1 ~ t2
------------------------ :: Sym
S;G |-co sym g : t2 ~ t1

S;G |-co g1 : t1 ~ t2
S;G |-co g2 : t2 ~ t3
-------------------------- :: Trans
S;G |-co g1 ;; g2 : t1 ~ t3

S;G |-co h : k1 ~ k2  // |t1| = |t2|
S;G |-ty t1 : k1  //  S;G |-ty t2 : k2
-------------------------------- :: Coherence
S;G |-co erase_h t1 t2 : t1 ~ t2

forall i: S;G |-co gi : si ~ si'
S;G |-ty H{ss} : k1  //  S;G |-ty H{ss'} : k2
------------------------------- :: Con
S;G |-co H{gs} : H{ss} ~ H{ss'}

S;G |-co g1 : t1 ~ t2
S;G |-co g2 : s1 ~ s2
S;G |-ty t1 s1 : k1 // S;G |-ty t2 s2 : k2
-------------------------- :: AppRel
S;G |-co g1 g2 : t1 s1 ~ t2 s2

S;G |-co g1 : t1 ~ t2
S;G |-co g2 : s1 ~ s2
S;G |-ty t1 {s1} : k1 // S;G |-ty t2 {s2} : k2
-------------------------- :: AppIrrel
S;G |-co g1 {g2} : t1 {s1} ~ t2 {s2}

S;G |-co g0 : t1 ~ t2
S;G |-ty t1 g1 : k1 // S;G |-ty t2 g2 : k2
-------------------------- :: CApp
S;G |-co g1 (g1,g2) : t1 g1 ~ t2 g2

S;G |-co h : k1 ~ k2  //  S;G |-ty k2 : Type{}
S;G,a:Rel k1 |-co g : s1 ~ s2
S;G,a:Rel k1 |-ty s1 : Type{}  //  S;G,a:Rel k1 |-ty s2 : Type{}
-------------------------------- :: PiTy
S;G |-co PI a :rel h. g : PI a:rel k1.s1 ~ PI a:rel k2.(s2[a |> sym h/a])

S;G |-co h1 : t1 ~ t2  //  S;G |-co h2 : s1 ~ s2
S;G |-prop t2 ~ s2 //  S;G,c:t1~s1 |-co g : k1 ~ k2
S;G,c:t1~s1 |-ty k1 : Type{}  //  S;G,c:t1~s1 |-ty k2 : Type{}
------------------------------ :: PiCo
S;G |-co PI c:(h1,h2).g : (PI c:t1 ~ s1. k1) ~ (PI c:t2 ~ s2.(k2[h1 ;; c ;; sym h2/c]))

S;G |-co h : k1 ~ k2  //  S;G |-co g0 : t1 ~ t2
forall i: S;G |-co gi : si ~ s'i
alts1 = list of Hi -> si  // alts2 = list of Hi -> s'i
S;G |-ty case_k1 t1 of alts1 : k1  // S;G |-ty case_k2 t2 of alts2 : k2
------------------------------ :: Case
S;G |-co case_h g0 of list of Hi -> gi : case_k1 t1 of alts1 ~ case_k2 t2 of alts2

S;G |-co h : k1 ~ k2  //  S;G |-ty k2 : Type{}
S;G, a :rel k1 |-co g : t1 ~ t2
S;G, a :rel k1 |-ty t1 : s1  //  S;G, a:rel k1 |-ty t2 : s2
------------------------------------- :: Lam
S;G |-co \a :rel h . g : \a:rel k1.t1 ~ \a:rel k2.(t2[a |> sym h/a])

S;G |-co h1 : t1 ~ t2 // S;G |-co h2 : s1 ~ s2
S;G,c:t1~s1 |-co g : k1 ~ k2
------------------------------- :: CLam
S;G |-co \c:(h1,h2).g : \c:t1~s1.k1 ~ \c:t2 ~ s2.(k2[h1 ;; c ;; sym h2 / c])

S;G |-co g : t1 ~ t2
S;G |-ty fix t1 : k1 // S;G |-ty fix t2 : k2
-------------------------------- :: Fix
S;G |-co fix g : fix t1 ~ fix t2

S;G |-co g : PI a:rel k1. s1 ~ PI a:rel k2. s2
------------------------- :: ArgK
S;G |-co argk g : k1 ~ k2

S;G |-co g : PI c:t1 ~ t1'.s1 ~ PI c:t2 ~ t2'.s2
-------------------------------- :: CArgK1
S;G |-co argk 1 g : t1 ~ t2

S;G |-co g : PI c:t1 ~ t1'.s1 ~ PI c:t2 ~ t2'.s2
----------------------------- :: CArgK2
S;G |-co argk 2 g : t1' ~ t2'

S;G |-co g : \a:rel k1.s1 ~ \a:rel k2.s2
------------------------- :: ArgKLam
S;G |-co argk g : k1 ~ k2

S;G |-co g : \c:t1 ~ t1'.s1 ~ \c:t2 ~ t2'.s2
--------------------- :: CArgKLam1
S;G |-co argk 1 g : t1 ~ t2

S;G |-co g : \c:t1 ~ t1'.s1 ~ \c:t2 ~ t2'.s2
--------------------- :: CArgKLam2
S;G |-co argk 2 g : t1' ~ t2'

S;G |-co g : PI a:rel k1. s1 ~ PI a:rel k2. s2
S;G |-co h : t1 ~ t2
S;G |-ty t1 : k1  //  S;G |-ty t2 : k2
-------------------------- :: Inst
S;G |-co g@h : s1[t1/a] ~ s2[t2/a]

S;G |-co h1 : PI c:phi1. s1 ~ PI c:phi2.s2
S;G |-co g1 : phi1  //   S;G |-co g2 : phi2
-------------------------- :: CInst
S;G |-co h1@(g1,g2) : s1[g1/c] ~ s2[g2/c]

S;G |-co g : \a:rel k1.t1 ~ \a:rel k2.t2
S;G |-co h : s1 ~ s2
S;G |-ty s1 : k1  //  S;G |-ty s2 : k2
--------------------------- :: InstLam
S;G |-co g@\h : t1[s1/a] ~ t2[s2/a]

S;G |-co g : \c:phi1. s1 ~ \c:phi2.s2
S;G |-co h1 : phi1 // S;G |-co h2 : phi2
---------------------------- :: CInstLam
S;G |-co g@\(h1,h2) : s1[h1/c] ~ s2[h2/c]

S;G |-co g : H{ks} ps ~ H{ks'} ps'
pi = t  //  pi' = s
-------------------------- :: Nth
S;G |-co nth i g : t ~ s

S;G |-co g : t1 ~ t2
S;G |-ty t1 : k1  //  S;G |-ty t2 : k2
------------------------- :: Kind
S;G |-co kind g : k1 ~ k2

S;G |-ty t : k   //  S;G |-s t --> t'
------------------------ :: Step
S;G |-co step t : t ~ t'

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Propositions  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S ; G |-prop phi :: :: Prop :: 'Prop_'
  {{ tex [[S]];[[G]] [[|-prop]] [[phi]] \ok }}
  {{ com Proposition formation }}
by

S;G |-ty t1 : k1
S;G |-ty t2 : k2
------------------ :: Equality
S;G |-prop t1 ~ t2


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Vectors  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S ; G |-vec ps : D :: :: Vec :: 'Vec_'
  {{ com Type vector formation }}
by

S |-ctx G
----------------------- :: Nil
S;G |-vec empty : empty

S;G |-ty t : k
S;G |-vec ps : D[t/a]
-------------------------- :: TyRel
S;G |-vec t,ps : a:Rel k,D

S;Rel(G) |-ty t : k
S;G |-vec ps : D[t/a]
-------------------------- :: TyIrrel
S;G |-vec t,ps : a:Irrel k,D

S;Rel(G) |-co g : phi
S;G |-vec ps : D[g/c]
------------------------ :: Co
S;G |-vec g,ps : c:phi,D


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Signatures  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
|-sig S :: :: Sig :: 'Sig_'
  {{ com Signature formation }}
by

----------- :: Boot
|-sig S0

S |-ctx as :Irrel ks  // T # S
----------------- :: ADT
|-sig S, T : (as:ks)

T : (as:ks) \in S   //  S |-ctx as:Irrel ks, D  // K # S
------------------- :: DataCon
|-sig S, K : (D; T)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Contexts  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
S |-ctx G :: :: Ctx :: 'Ctx_'
  {{ com Context formation }}
by

|-sig S
-------------- :: Nil
S |-ctx empty

S;Rel(G) |-ty k : Type{}  //  a # G  //  S |-ctx G
-------------- :: TyVar
S |-ctx G, a:rel k

S;Rel(G) |-prop phi  // c # G   // S |-ctx G
---------------- :: CoVar
S |-ctx G, c:phi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Reduction  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JStep :: '' ::=

defn
S ; G |-s s --> s' :: :: Step :: 'S_'
  {{ com Small-step operational semantics }}
by

------------------------- :: BetaRel
S;G |-s (\a:Rel k.s1) s2 --> s1[s2/a]

---------------------------------------- :: BetaIrrel
S;G |-s (\a:Irrel k.s1) {s2} --> s1[s2/a]

------------------------------- :: CBeta
S;G |-s (\c:phi.s) g --> s[g/c]

alti = H -> t0  // other alternatives do not match H
---------------------------- :: Match
S;G |-s case_k H{ts} ps of alts --> t0 ps <H{ts} ps>

t = \a:rel k.s
---------------------------- :: Unroll
S;G |-s fix t --> s[fix t/a]

---------------------------------- :: Trans
S;G |-s (v |> g1) |> g2 --> v |> (g1 ;; g2)

S;G,a:Irrel k |-s s --> s'
------------------------------------- :: IrrelAbs_Cong
S;G |-s \a :Irrel k.s --> \a :Irrel k. s'

S;G |-s s1 --> s1'
---------------- :: AppRel_Cong
S;G |-s s1 s2 --> s1' s2

S;G |-s s1 --> s1'
------------------ :: AppIrrel_Cong
S;G |-s s1 {s2} --> s1' {s2}

S;G |-s s --> s'
------------------ :: Cast_Cong
S;G |-s s |> g --> s' |> g

S;G |-s s --> s'
-------------------------------------- :: Case_Cong
S;G |-s case_t s of alts --> case_t s' of alts

S;G |-s t --> t'
------------------------ :: Fix_Cong
S;G |-s fix t --> fix t'

S;G |-ty v : PI a:rel k. s
g1 = sym (argk g0)      //   g2 = g0@(erase_(sym g1) (t |> g1) t)
% g0 : PI a:rel k. s ~ PI a:rel k'. s'
% g1 : k' ~ k
% g2 : s[(t |> g1)/a] ~ s'[t/a]
----------------------------------------- :: Push
S;G |-s (v |> g0) t --> v (t |> g1) |> g2

S;G |-ty v : PI c:phi. s
g1 = argk 1 g0 //  g2 = argk 2 g0
h' = g1 ;; h ;; g2  //  g3 = g0@(h', h)
--------------------------------------------- :: CPush
S;G |-s (v |> g0) h --> v h' |> g3

----------------------------------- :: APush
S;G |-s \a :Irrel k. (v |> g) --> (\a :Irrel k. v) |> (UPI a:Irrel <k>. g)

S |-tc H : as:Irrel ks;D;H'
S;G |-co h : H'{} ps ~ H'{} ps'
forall j: wj = mk_nth(g;j;pj;pj')
forall i: gi = build_kpush_co(<k>@ws;ps_{0..i-1})
forall i: pi' = cast_kpush_arg(pi;gi)
% kind K = MPI as :Irrel ks. MPI D. T as
% si' = s' |> argk (kind K @ nths h @ ...)
----------------------------------------------------------------- :: KPush
S;G |-s case_k0 (H{ts} ps) |> h of alts --> case_k0 H{ts'} ps' of alts

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Parallel reduction  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JRed :: '' ::=

defn
t ~> t' :: :: Red :: 'R_'
  {{ com Type parallel reduction, over erased types }}
by

-------------- :: Refl
t ~> t

t ~> t' // s ~> s'
-------------------- :: AppRel
t s ~> t' s'

t ~> t' // s ~> s'
-------------------- :: AppIrrel
t {s} ~> t' {s'}

t ~> t'
----------- :: CApp
t o ~> t' o

d ~> d'   //  t ~> t'
---------------------------------------- :: Pi
PI d. t ~> PI d'. t'

k ~> k'  //  t ~> t'  //  ss ~> ss'
---------------- :: Case
case_k t of list of H -> s ~> case_k' t' of list of H -> s'

d ~> d'  // t ~> t'
-------------- :: Lam
\d.t ~> \d'.t'

t ~> t'
--------------- :: Fix
fix t ~> fix t'

t1 ~> t1'  // t2 ~> t2'
------------------------------ :: BetaRel
(\a :Rel k. t1) t2 ~> t1'[t2'/a]

t1 ~> t1'  // t2 ~> t2'
------------------------------ :: BetaIrrel
(\a :Irrel k. t1) {t2} ~> t1'[t2'/a]

t ~> t'
------------------ :: CBeta
(\o:phi.t) o ~> t'

alti = H -> t0  // ps ~> ps' // t0 ~> t0'
other alternatives do not match H
----------------------------------- :: Match
case_k H** ps of alts ~> t0' ps' o

s ~> s' // k ~> k'
------------------- :: Unroll
fix (\a:rel k.s) ~> s'[fix (\a:rel k'.s')/a]

defn
d ~> d' :: :: RedBnd :: 'R_'
  {{ com Parallel reduction of binder }}
by

k ~> k'
--------------------- :: TyBinder
a :rel k ~> a :rel k'

s1 ~> s2 // t1 ~> t2
---------- :: CoBinder
o:s1 ~ t1 ~> o:s2 ~ t2

defn
g ~> g'  :: :: RedCo :: 'R_'
  {{ com ``Reduction'' of erased coercion }}
by

------ :: ErasedCo
o ~> o
